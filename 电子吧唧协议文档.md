# BLE文件传输协议设计文档
## 适用于电子吧唧产品的图片/视频/GIF传输协议

### 版本信息
- **协议版本**: v1.0
- **设计日期**: 2025-01-27
- **适用产品**: 电子吧唧产品
- **支持文件类型**: 图片、视频、GIF

### 文档说明
本文档定义了基于BLE(蓝牙低功耗)的文件传输协议，专门用于电子吧唧产品与APP之间的图片、视频、GIF文件传输。协议采用三级Key结构，支持大文件分片传输、错误检测重传、传输进度跟踪等功能。

---

## 1. 协议概述

### 1.1 协议特点
- 基于BLE (Bluetooth Low Energy) 通信
- 支持大文件分片传输
- 支持文件元数据传输（时间、贴纸等元素）
- 支持多种文件格式
- 具备错误检测和重传机制

### 1.2 传输文件类型
- **图片文件**: JPG, PNG, BMP, WEBP
- **视频文件**: MP4, AVI, MOV
- **动画文件**: GIF, APNG
- **元数据**: 时间戳、贴纸信息、位置信息等

---

## 2. 数据包格式

### 2.1 整体数据包结构
```
数据包总长度: 5~512 bytes
┌─────────────────┬─────────────────┐
│  数据包头部     │     数据部分    │
│  (3 bytes)      │   (0~507 bytes) │
└─────────────────┴─────────────────┘

注释:
- 数据包头部: 固定3字节，包含起始标识符和数据长度
- 数据部分: 可变长度，包含命令ID和载荷数据
- 总长度限制: BLE MTU限制，最大512字节
```

### 2.2 数据包头部格式 (3 bytes)
```
┌─────────────┬─────────────────────┐
│ 起始标识符  │    数据总长度        │
│  (1 byte)   │    (2 bytes)        │
│   0xCD      │   Data总长度        │
└─────────────┴─────────────────────┘
```

**字段说明:**
- **起始标识符**: 固定值 `0xCD`，用于标识数据包开始
  - 作用: 数据包同步，确保接收方知道数据包开始位置
  - 选择原因: 避免与数据内容冲突的固定标识
- **数据总长度**: 数据部分的总字节数 (0-507)
  - 作用: 告诉接收方数据部分有多少字节
  - 范围: 0-507字节 (BLE MTU限制)

---

## 3. 数据部分格式

### 3.1 数据部分结构
```
┌─────────────┬─────────────────────┐
│ 命令ID      │     载荷数据        │
│ (2 bytes)   │   (0~505 bytes)     │
└─────────────┴─────────────────────┘
```

### 3.2 命令ID格式 (2 bytes)
```
┌─────────────┬─────────────────────┐
│ 产品标识    │     协议版本        │
│ (1 byte)    │     (1 byte)        │
│   0x25      │       0x01          │
└─────────────┴─────────────────────┘
```

**字段说明:**
- **产品标识**: 固定值 `0x25`，表示"电子吧唧产品"
  - 作用: 区分不同产品的协议，避免冲突
  - 扩展性: 其他产品可以使用不同的产品标识
- **协议版本**: 当前版本 `0x01` (v1.0)
  - 作用: 协议版本控制，支持向后兼容
  - 升级: 协议升级时递增版本号

---

## 4. 功能模块定义

### 4.1 三级Key结构说明

**协议采用三级Key结构:**
- **第一级Key (Command ID)**: 0x25 (BAJI_PRODUCT)
- **第二级Key**: 功能模块标识 (0x01-0x03)
- **第三级Key**: 具体命令标识 (0x00-0x20)

### 4.2 第二级Key定义
| 键值 | 名称 | 描述 |
|------|------|------|
| 0x01 | FILE_TRANSFER | 文件传输功能 |
| 0x02 | MEDIA_MANAGEMENT | 媒体管理功能 |
| 0x03 | SYSTEM_INFO | 系统信息功能 |

### 4.3 FILE_TRANSFER (0x01) - 文件传输功能

#### 4.3.1 传输准备阶段命令
| 键值 | 名称 | 数据类型 | 描述 |
|------|------|----------|------|
| 0x00 | TRANSFER_START | - | 开始文件传输 |
| 0x01 | TRANSFER_STOP | - | 停止文件传输 |
| 0x02 | TRANSFER_ACK | - | 传输确认 |
| 0x03 | TRANSFER_NACK | - | 传输拒绝 |

**注释说明:**
- **准备阶段**: 在开始实际数据传输前的协商阶段
- **TRANSFER_START**: APP发送，携带文件信息(文件名、大小、类型等)
- **TRANSFER_ACK**: 设备确认可以开始传输
- **TRANSFER_NACK**: 设备拒绝传输，需携带拒绝原因

**传输拒绝原因定义:**
当设备返回 `TRANSFER_NACK (0x05)` 时，需要携带拒绝原因：

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x05 | TRANSFER_NACK命令 |
| 1 | 1 | [拒绝原因] | 拒绝原因代码 |

**拒绝原因代码:**
| 代码 | 原因 | 描述 |
|------|------|------|
| 0x01 | 文件过大 | 文件大小超出设备限制 |
| 0x02 | 文件类型不支持 | 设备不支持该文件类型 |
| 0x03 | 存储空间不足 | 设备存储空间不够 |
| 0x04 | 设备忙 | 设备正在处理其他任务 |
| 0x05 | 文件ID冲突 | 文件ID已存在 |
| 0x06 | 参数错误 | 文件信息参数有误 |

**注释说明:**
- **拒绝原因**: 帮助APP了解具体拒绝原因，提供用户友好的错误提示
- **扩展性**: 可以根据需要添加新的拒绝原因代码
- **用户友好**: APP可以根据原因代码显示相应的错误信息给用户

#### 4.3.2 数据传输阶段命令
| 键值 | 名称 | 数据类型 | 描述 |
|------|------|----------|------|
| 0x17 | NEXT_CHUNK_REQUEST | uint8 | 请求下一块 |
| 0x19 | RETRY_REQUEST | uint8 | 重传请求 |
| 0x1A | TRANSFER_COMPLETE | uint8 | 传输完成标志 |
| 0x1D | STATUS | uint8 | 状态标志 |
| 0x1F | RESERVED | - | 预留扩展 |
| 0x20 | RESERVED | - | 预留扩展 |

**注释说明:**
- **传输阶段**: 实际文件数据块的传输过程
- **NEXT_CHUNK_REQUEST**: 设备请求APP发送下一个数据块
- **RETRY_REQUEST**: 数据块传输失败时，设备请求重传
- **TRANSFER_COMPLETE**: APP通知设备所有数据块已传输完成
- **错误处理**: 支持传输过程中的错误检测和重传机制

**STATUS状态标志详细说明:**
STATUS用于表示当前传输过程中的各种状态信息，APP可以通过查询状态了解传输进度。

**APP状态查询流程:**

#### **1. 状态查询请求**
APP向设备发送状态查询请求：
```
数据包结构:
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x1D | STATUS命令 |

完整数据包:
0xCD 0x00 0x04 0x25 0x01 0x01 0x1D
```

#### **2. 设备状态响应**
设备返回当前状态信息：
```
数据包结构:
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x1D | STATUS命令 |
| 2 | 1 | [状态值] | 当前状态(见状态值定义) |

完整数据包:
0xCD 0x00 0x06 0x25 0x01 0x01 0x1D [状态值]
```

#### **3. APP状态查询实现示例**

**Android (Kotlin) 实现:**
```kotlin
class BLEFileTransfer {
    private fun queryDeviceStatus() {
        // 构建状态查询请求
        val request = byteArrayOf(
            0xCD.toByte(), 0x00, 0x04, 0x25, 0x01,  // 包头
            0x01, 0x1D                              // 载荷: FILE_TRANSFER + STATUS
        )
        
        // 发送请求
        bluetoothGatt.writeCharacteristic(characteristic, request)
    }
    
    private fun handleStatusResponse(data: ByteArray) {
        if (data.size >= 7 && data[5] == 0x01.toByte() && data[6] == 0x1D.toByte()) {
            val status = data[7].toInt() and 0xFF
            updateUI(status)
        }
    }
    
    private fun updateUI(status: Int) {
        when (status) {
            0x00 -> showStatus("空闲状态")
            0x01 -> showStatus("准备中...")
            0x02 -> showStatus("传输中...")
            0x03 -> showStatus("传输完成")
            0x04 -> showStatus("传输错误")
            0x05 -> showStatus("已取消")
        }
    }
}
```

**iOS (Objective-C) 实现:**
```objc
- (void)queryDeviceStatus {
    // 构建状态查询请求
    uint8_t request[] = {0xCD, 0x00, 0x04, 0x25, 0x01, 0x01, 0x1D};
    NSData *requestData = [NSData dataWithBytes:request length:7];
    
    // 发送请求
    [self.peripheral writeValue:requestData 
              forCharacteristic:self.characteristic 
                           type:CBCharacteristicWriteWithResponse];
}

- (void)handleStatusResponse:(NSData *)data {
    const uint8_t *bytes = (const uint8_t *)data.bytes;
    if (data.length >= 7 && bytes[5] == 0x01 && bytes[6] == 0x1D) {
        uint8_t status = bytes[7];
        [self updateUIWithStatus:status];
    }
}

- (void)updateUIWithStatus:(uint8_t)status {
    switch (status) {
        case 0x00:
            [self showStatus:@"空闲状态"];
            break;
        case 0x01:
            [self showStatus:@"准备中..."];
            break;
        case 0x02:
            [self showStatus:@"传输中..."];
            break;
        case 0x03:
            [self showStatus:@"传输完成"];
            break;
        case 0x04:
            [self showStatus:@"传输错误"];
            break;
        case 0x05:
            [self showStatus:@"已取消"];
            break;
    }
}
```

#### **4. 状态查询时机**
APP应该在以下时机查询设备状态：
- **传输开始前**: 确认设备是否准备就绪
- **传输过程中**: 定期查询进度(建议每2-3秒查询一次)
- **传输完成后**: 确认完成状态
- **错误发生时**: 查询错误状态

#### **5. 状态查询频率建议**
- **正常传输**: 每2-3秒查询一次
- **错误状态**: 每1秒查询一次
- **空闲状态**: 每10秒查询一次

#### **6. 状态查询超时处理**
```kotlin
private fun queryStatusWithTimeout() {
    queryDeviceStatus()
    
    // 设置超时处理
    handler.postDelayed({
        if (!statusReceived) {
            showError("状态查询超时")
            // 重新连接或重试
        }
    }, 3000) // 3秒超时
}
```

**状态值定义:**
| 状态值 | 状态名称 | 描述 |
|--------|----------|------|
| 0x00 | IDLE | 空闲状态，未开始传输 |
| 0x01 | PREPARING | 准备状态，正在协商文件信息 |
| 0x02 | TRANSFERRING | 传输中，正在传输数据块 |
| 0x03 | COMPLETED | 完成状态，传输已完成 |
| 0x04 | ERROR | 错误状态，传输出现错误 |
| 0x05 | CANCELLED | 取消状态，传输被取消 |

**如何获取状态:**
1. **主动查询**: APP发送状态查询请求
2. **被动接收**: 设备主动推送状态变化
3. **状态同步**: 确保APP和设备状态一致

#### 4.3.3 开始传输时携带的文件信息
当APP点击"开始发送"时，需要携带以下文件信息：

**单文件传输结构:**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x00 | TRANSFER_START命令 |
| 1 | 1 | 0x07 | FILE_SIZE标识 |
| 2 | 4 | [文件大小] | 文件大小(字节) |
| 6 | 1 | 0x08 | FILE_TYPE标识 |
| 7 | 1 | [文件类型] | 文件类型值(0x01-0x03) |
| 8 | 1 | 0x0A | FUNCTION_TYPE标识 |
| 9 | 1 | [功能类型] | 功能类型值(0x01-0x04) |
| 10 | 1 | 0x09 | MEDIA_ID标识 |
| 11 | 4 | [媒体ID] | 媒体唯一标识符 |

**多文件合并传输结构:**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x00 | TRANSFER_START命令 |
| 1 | 1 | 0x07 | FILE_SIZE标识 |
| 2 | 4 | [合并文件总大小] | 合并文件总大小(字节) |
| 6 | 1 | 0x08 | FILE_TYPE标识 |
| 7 | 1 | 0xFF | 多文件合并类型标识 |
| 8 | 1 | 0x09 | MEDIA_ID标识 |
| 9 | 4 | [媒体ID] | 媒体唯一标识符 |
| 13 | 1 | 0x0A | FILE_COUNT标识 |
| 14 | 1 | [文件数量] | 包含的文件数量(1-255) |
| 15-M | 可变 | [文件信息列表] | 每个文件的详细信息 |

**单个文件信息结构:**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x0B | FILE_INFO标识 |
| 1 | 1 | [功能类型] | 功能类型(0x01=背景图功能, 0x02=贴纸功能, 0x03=字体功能, 0x04=预览图功能) |
| 2 | 4 | [文件大小] | 文件大小(字节) |
| 6 | 4 | [文件偏移] | 在合并文件中的偏移位置 |
| 10 | 1 | [属性数量] | 文件属性数量(0-255) |
| 11-N | 可变 | [属性列表] | 文件属性列表，根据功能类型而定 |

**文件属性结构:**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | [属性类型] | 属性类型(0x01=坐标) |
| 1 | 1 | [属性长度] | 属性数据长度(字节数) |
| 2-N | 可变 | [属性数据] | 属性具体数据 |

**无属性表示方法:**
- 当文件不需要任何属性时，`[属性数量]` 字段设置为 `0x00`
- 此时不包含任何属性结构，直接结束文件信息
- 例如：背景图通常不需要坐标属性，属性数量为0

**属性类型定义:**

| 属性类型 | 名称 | 数据长度 | 说明 |
|---------|------|----------|------|
| 0x01 | 坐标属性 | 4字节 | 包含X、Y坐标信息 |
| 0x02-0xFF | 预留 | - | 为未来扩展预留 |

**坐标属性数据结构 (属性类型=0x01):**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 2 | [X坐标] | X轴坐标(相对于背景图左上角) |
| 2 | 2 | [Y坐标] | Y轴坐标(相对于背景图左上角) |

**注释说明:**
- **文件信息协商**: 在开始传输前，APP需要告诉设备文件的基本信息
- **设备预检查**: 设备可以根据这些信息判断是否可以接收文件
- **分块计算**: 设备可以提前知道需要接收多少个数据块
- **存储检查**: 设备可以检查是否有足够的存储空间
- **属性处理**: 设备根据属性数量判断是否需要解析属性信息
- **无属性文件**: 当属性数量为0时，设备直接使用文件，无需解析属性

**文件类型定义:**
| 类型值 | 文件类型 | 扩展名 |
|--------|----------|--------|
| 0x01 | 图片 | JPG, PNG, BMP, WEBP |
| 0x02 | 视频 | MP4, AVI, MOV |
| 0x03 | 动画 | GIF, APNG |
| 0xFF | 多文件合并 | 包含多个文件的合并包 |

**功能类型定义:**
| 类型值 | 功能类型 | 说明 |
|--------|----------|------|
| 0x01 | 背景图功能 | 主背景图片功能 |
| 0x02 | 贴纸功能 | 贴纸图片功能 |
| 0x03 | 字体功能 | 字体样式功能 |
| 0x04 | 预览图功能 | 预览图片功能 |
| 0x05-0xFF | 预留 | 为未来扩展预留 |

**注释说明:**
- **功能类型**: 这些是功能分类，不是文件类型，用于标识文件在电子吧唧产品中的用途
- **文件类型**: 实际的文件类型仍然是图片(0x01)、视频(0x02)、动画(0x03)等
- **功能标识**: 通过功能类型让设备知道如何处理这个文件(作为背景图、贴纸、字体等)
- **单文件传输**: 需要同时指定文件类型和功能类型
- **多文件合并**: 在多文件合并包中使用功能类型，便于设备识别和处理

**多文件合并传输示例:**
```
假设要传输一个包含背景图、贴纸和字体的组合包:
- 文件1: 背景图功能 (图片文件, 1024字节, 无属性)
- 文件2: 贴纸功能 (图片文件, 512字节, 包含坐标属性)
- 文件3: 字体功能 (字体文件, 2048字节, 包含坐标属性)

完整传输开始数据包:
0xCD 0x00 0x20 0x25 0x01 0x00 0x07 0x00 0x00 0x0E 0x00 0x08 0xFF 0x09 0x00 0x00 0x00 0x01 0x0A 0x03 0x0B 0x01 0x00 0x00 0x04 0x00 0x00 0x00 0x00 0x00 0x0B 0x02 0x00 0x00 0x02 0x00 0x00 0x00 0x04 0x00 0x01 0x01 0x04 0x00 0x64 0x00 0x32 0x0B 0x03 0x00 0x00 0x08 0x00 0x00 0x00 0x06 0x00 0x01 0x01 0x04 0x00 0xC8 0x00 0x1E

数据包解析:
- 0xCD 0x00 0x20: 包头(数据长度32字节)
- 0x25 0x01: 命令ID和版本
- 0x00: TRANSFER_START命令
- 0x07: FILE_SIZE标识
- 0x00 0x00 0x0E 0x00: 合并文件总大小(3584字节)
- 0x08: FILE_TYPE标识
- 0xFF: 多文件合并类型
- 0x09: MEDIA_ID标识
- 0x00 0x00 0x00 0x01: 媒体ID(1)
- 0x0A: FILE_COUNT标识
- 0x03: 文件数量(3个)

第一个文件信息(背景图):
- 0x0B: FILE_INFO标识
- 0x01: 功能类型(背景图功能)
- 0x00 0x00 0x04 0x00: 文件大小(1024字节)
- 0x00 0x00 0x00 0x00: 文件偏移(0字节)
- 0x00: 属性数量(0个，背景图无属性)

第二个文件信息(贴纸):
- 0x0B: FILE_INFO标识
- 0x02: 功能类型(贴纸功能)
- 0x00 0x00 0x02 0x00: 文件大小(512字节)
- 0x00 0x00 0x04 0x00: 文件偏移(1024字节)
- 0x01: 属性数量(1个)
- 0x01: 属性类型(坐标)
- 0x04: 属性长度(4字节)
- 0x00 0x64 0x00 0x32: 坐标(100, 50)

第三个文件信息(字体):
- 0x0B: FILE_INFO标识
- 0x03: 功能类型(字体功能)
- 0x00 0x00 0x08 0x00: 文件大小(2048字节)
- 0x00 0x00 0x06 0x00: 文件偏移(1536字节)
- 0x01: 属性数量(1个)
- 0x01: 属性类型(坐标)
- 0x04: 属性长度(4字节)
- 0x00 0xC8 0x00 0x1E: 坐标(200, 30)
```

#### 4.3.4 数据传输过程中的信息
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x0A | FILE_DATA命令标识 |
| 1 | 1 | [数据块大小] | 当前数据块的字节数 |
| 2-N | N | [数据块内容] | 实际的文件数据 |
| N+1-N+2 | 2 | [数据块索引] | 数据块索引(从0开始) |
| N+3-N+6 | 4 | [校验和] | CRC32校验和 |

**其他相关命令:**
| 键值 | 名称 | 数据类型 | 描述 |
|------|------|----------|------|
| 0x18 | RECEIVED_CHECKSUM | uint32 | 接收到的校验和 |
| 0x1B | TOTAL_TRANSFERRED | uint32 | 总传输字节数 |
| 0x1C | VERIFICATION_RESULT | uint8 | 文件验证结果 |

**数据块传输包结构说明:**
当APP发送 `FILE_DATA (0x0A)` 命令时，需要在一个数据包中包含上述表格中的所有信息。

**注释说明:**
- **FILE_DATA**: 实际的文件数据内容，每个数据块包含文件的一部分
- **CHUNK_INDEX**: 数据块索引，从0开始编号，用于标识这是第几块数据
- **CHUNK_SIZE**: 当前数据块的大小(字节数)，用于验证数据完整性
- **CHECKSUM**: 数据块的校验和，用于检测传输错误
- **数据完整性**: 通过索引、大小、校验和确保数据块传输的完整性

**CHECKSUM校验码算法说明:**
CHECKSUM用于验证数据块在传输过程中的完整性，采用CRC32算法计算校验和。

**算法选择: CRC32**
- **算法名称**: CRC32 (Cyclic Redundancy Check 32-bit)
- **多项式**: 0x04C11DB7 (IEEE 802.3标准)
- **初始值**: 0xFFFFFFFF
- **输出异或**: 0xFFFFFFFF
- **数据宽度**: 32位 (4字节)

**CRC32算法实现 (C语言):**
```c
// CRC32查找表 (完整256个表项)
static const uint32_t crc32_table[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0,
    0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447,
    0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
    0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11,
    0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934,
    0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B,
    0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE,
    0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
    0xAA0A4C5F, 0xDD0D7CC9, 0x2505713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998,
    0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF,
    0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2,
    0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9,
    0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
    0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703,
    0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226,
    0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D,
    0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70,
    0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
    0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A,
    0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1,
    0x5A05DF1B, 0x2D02EF8D
};

// 计算CRC32校验和
uint32_t calculate_crc32(const uint8_t* data, size_t length) {
    uint32_t crc = 0xFFFFFFFF;
    
    for (size_t i = 0; i < length; i++) {
        uint8_t table_index = (crc ^ data[i]) & 0xFF;
        crc = (crc >> 8) ^ crc32_table[table_index];
    }
    
    return crc ^ 0xFFFFFFFF;
}
```


**校验和验证流程:**
1. **发送方**: 计算数据块的CRC32校验和，随数据块一起发送
2. **接收方**: 接收数据块后，重新计算CRC32校验和
3. **比较验证**: 比较发送和接收的校验和是否一致
4. **结果处理**: 
   - 一致: 数据块传输正确，继续下一块
   - 不一致: 数据块传输错误，请求重传

**校验和优势:**
- **高可靠性**: CRC32能检测99.9%以上的传输错误
- **计算效率**: 使用查找表，计算速度快
- **标准算法**: 广泛使用，兼容性好
- **错误检测**: 能检测单比特、多比特、突发错误

#### 4.3.5 文件完整性最终验证

**最终验证流程说明:**
当所有数据块传输完成后，需要进行完整的文件验证以确保文件完整性。

#### **验证步骤:**

**1. 块完整性验证**
```
设备端验证:
- 检查所有数据块是否按顺序接收
- 验证每个数据块的CRC32校验和
- 确认没有缺失的数据块
- 验证数据块索引的连续性
```

**2. 文件完整性验证**
```
设备端验证:
- 重新计算整个文件的CRC32校验和
- 与发送方提供的文件总校验和进行比较
- 验证文件大小是否匹配
- 检查文件头信息是否正确
```

**3. 验证结果响应**
```
设备向APP发送验证结果:
数据包结构:
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x1C | VERIFICATION_RESULT命令 |
| 2 | 1 | [验证结果] | 验证结果代码 |

验证结果代码:
| 代码 | 结果 | 描述 |
|------|------|------|
| 0x00 | 验证成功 | 文件完整，传输成功 |
| 0x01 | 校验和错误 | 文件CRC32校验和不匹配 |
| 0x02 | 文件大小错误 | 文件大小不匹配 |
| 0x03 | 数据块缺失 | 部分数据块未接收 |
| 0x04 | 数据块顺序错误 | 数据块顺序不正确 |
| 0x05 | 文件头错误 | 文件头信息不正确 |
```

#### **完整验证流程示例:**

**APP发送传输完成通知(携带文件校验码):**
```
数据包结构:
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x1A | TRANSFER_COMPLETE命令 |
| 2-5 | 4 | [文件CRC32] | 原始文件的CRC32校验码 |

完整数据包:
0xCD 0x00 0x08 0x25 0x01 0x01 0x1A [CRC32_1] [CRC32_2] [CRC32_3] [CRC32_4]
```

**设备进行最终验证:**
```
设备内部验证过程:
1. 检查接收到的数据块数量
2. 验证数据块索引连续性 (0, 1, 2, ..., N-1)
3. 从缓存中获取已存储的文件数据
4. 计算缓存文件的CRC32校验码
5. 与APP发送的CRC32校验码进行比较
6. 验证文件大小是否匹配
```

**设备返回验证结果:**
```
验证成功:
0xCD 0x00 0x06 0x25 0x01 0x01 0x1C 0x00

验证失败(校验和错误):
0xCD 0x00 0x06 0x25 0x01 0x01 0x1C 0x01
```

#### **APP端发送完成指令实现:**

**Android (Kotlin) 实现:**
```kotlin
class BLEFileTransfer {
    private fun sendTransferComplete(fileCRC32: Long) {
        // 构建传输完成指令(携带文件校验码)
        val request = byteArrayOf(
            0xCD.toByte(), 0x00, 0x08, 0x25, 0x01,  // 包头
            0x01, 0x1A,                              // FILE_TRANSFER + TRANSFER_COMPLETE
            ((fileCRC32 shr 24) and 0xFF).toByte(),  // CRC32 字节1
            ((fileCRC32 shr 16) and 0xFF).toByte(),  // CRC32 字节2
            ((fileCRC32 shr 8) and 0xFF).toByte(),   // CRC32 字节3
            (fileCRC32 and 0xFF).toByte()            // CRC32 字节4
        )
        
        // 发送完成指令
        bluetoothGatt.writeCharacteristic(characteristic, request)
    }
    
    private fun handleVerificationResult(data: ByteArray) {
    if (data.size >= 7 && data[5] == 0x01.toByte() && data[6] == 0x1C.toByte()) {
        val result = data[7].toInt() and 0xFF
        when (result) {
            0x00 -> {
                showSuccess("文件传输成功！")
                // 传输完成，可以断开连接
            }
            0x01 -> {
                showError("文件校验失败，请重新传输")
                // 重新开始传输
            }
            0x02 -> {
                showError("文件大小不匹配，请重新传输")
                // 重新开始传输
            }
            0x03 -> {
                showError("数据块缺失，请重新传输")
                // 重新开始传输
            }
            0x04 -> {
                showError("数据块顺序错误，请重新传输")
                // 重新开始传输
            }
            0x05 -> {
                showError("文件头错误，请重新传输")
                // 重新开始传输
            }
        }
    }
}
```

**iOS (Objective-C) 实现:**
```objc
- (void)sendTransferComplete:(uint32_t)fileCRC32 {
    // 构建传输完成指令(携带文件校验码)
    uint8_t request[] = {
        0xCD, 0x00, 0x08, 0x25, 0x01,  // 包头
        0x01, 0x1A,                    // FILE_TRANSFER + TRANSFER_COMPLETE
        (fileCRC32 >> 24) & 0xFF,      // CRC32 字节1
        (fileCRC32 >> 16) & 0xFF,      // CRC32 字节2
        (fileCRC32 >> 8) & 0xFF,       // CRC32 字节3
        fileCRC32 & 0xFF               // CRC32 字节4
    };
    
    NSData *requestData = [NSData dataWithBytes:request length:12];
    
    // 发送完成指令
    [self.peripheral writeValue:requestData 
              forCharacteristic:self.characteristic 
                           type:CBCharacteristicWriteWithResponse];
}

- (void)handleVerificationResult:(NSData *)data {
    const uint8_t *bytes = (const uint8_t *)data.bytes;
    if (data.length >= 7 && bytes[5] == 0x01 && bytes[6] == 0x1C) {
        uint8_t result = bytes[7];
        switch (result) {
            case 0x00:
                [self showSuccess:@"文件传输成功！"];
                // 传输完成，可以断开连接
                break;
            case 0x01:
                [self showError:@"文件校验失败，请重新传输"];
                // 重新开始传输
                break;
            case 0x02:
                [self showError:@"文件大小不匹配，请重新传输"];
                // 重新开始传输
                break;
            case 0x03:
                [self showError:@"数据块缺失，请重新传输"];
                // 重新开始传输
                break;
            case 0x04:
                [self showError:@"数据块顺序错误，请重新传输"];
                // 重新开始传输
                break;
            case 0x05:
                [self showError:@"文件头错误，请重新传输"];
                // 重新开始传输
                break;
        }
    }
}
```

#### **设备端验证实现:**

**设备端C语言实现:**
```c
// 设备端处理传输完成指令
void handle_transfer_complete(const uint8_t* data, size_t length) {
    if (length < 12) {
        send_verification_result(0x05); // 文件头错误
        return;
    }
    
    // 提取APP发送的文件CRC32
    uint32_t app_crc32 = (data[7] << 24) | (data[8] << 16) | (data[9] << 8) | data[10];
    
    // 从缓存中获取已存储的文件数据
    uint8_t* cached_file_data = get_cached_file_data();
    size_t cached_file_size = get_cached_file_size();
    
    // 计算缓存文件的CRC32
    uint32_t cached_crc32 = calculate_crc32(cached_file_data, cached_file_size);
    
    // 比较CRC32校验码
    if (app_crc32 == cached_crc32) {
        // 验证成功
        send_verification_result(0x00);
        // 保存文件到最终位置
        save_file_to_final_location(cached_file_data, cached_file_size);
    } else {
        // 校验和错误
        send_verification_result(0x01);
    }
}

// 发送验证结果
void send_verification_result(uint8_t result) {
    uint8_t response[] = {0xCD, 0x00, 0x06, 0x25, 0x01, 0x01, 0x1C, result};
    ble_send_data(response, 8);
}
```

#### **验证失败处理策略:**
1. **校验和错误**: 重新传输整个文件
2. **文件大小错误**: 检查文件信息，重新传输
3. **数据块缺失**: 重新传输缺失的数据块
4. **数据块顺序错误**: 重新传输整个文件
5. **文件头错误**: 检查文件格式，重新传输

#### **验证成功后的操作:**
1. **显示成功信息**: 告知用户传输完成
2. **保存文件**: 将接收到的数据保存为文件
3. **更新状态**: 将设备状态设置为IDLE
4. **断开连接**: 可以选择断开BLE连接

#### **完整传输流程示例:**

**1. APP端准备文件:**
```kotlin
// 计算原始文件的CRC32
val originalFile = File("image.jpg")
val fileData = originalFile.readBytes()
val fileCRC32 = calculateCRC32(fileData)

// 开始传输
startFileTransfer(originalFile)
```

**2. 传输所有数据块:**
```
APP发送: FILE_DATA + 数据块1 + CRC32
设备响应: NEXT_CHUNK_REQUEST

APP发送: FILE_DATA + 数据块2 + CRC32  
设备响应: NEXT_CHUNK_REQUEST

... (重复直到所有块传输完成)
```

**3. APP发送完成指令:**
```kotlin
// 所有数据块传输完成后
sendTransferComplete(fileCRC32)
```

**4. 设备端验证:**
```c
// 设备接收到完成指令
handle_transfer_complete(received_data, data_length);

// 从缓存获取文件数据并计算CRC32
uint32_t cached_crc32 = calculate_crc32(cached_data, cached_size);

// 比较校验码
if (app_crc32 == cached_crc32) {
    send_verification_result(0x00); // 成功
    save_file_to_final_location();  // 保存文件
} else {
    send_verification_result(0x01); // 失败
}
```

**5. APP处理验证结果:**
```kotlin
private fun handleVerificationResult(data: ByteArray) {
    val result = data[7].toInt() and 0xFF
    if (result == 0x00) {
        showSuccess("文件传输成功！")
        // 传输完成
    } else {
        showError("文件校验失败，请重新传输")
        // 重新开始传输
    }
}
```

#### **优化优势:**
1. **减少设备端计算**: 设备只需计算一次CRC32，不需要重新计算整个文件
2. **提高验证效率**: 直接比较校验码，验证速度快
3. **降低内存占用**: 设备端不需要存储额外的校验信息
4. **简化实现**: 验证逻辑更加简单直接
5. **提高可靠性**: APP端计算原始文件CRC32，确保准确性

### 4.4 MEDIA_MANAGEMENT (0x02) - 媒体管理功能

#### 4.4.1 媒体管理命令
| 键值 | 名称 | 数据类型 | 描述 |
|------|------|----------|------|
| 0x00 | MEDIA_LIST_REQUEST | - | 请求媒体列表 |
| 0x01 | MEDIA_LIST_RESPONSE | - | 媒体列表响应 |
| 0x02 | MEDIA_DELETE | - | 删除媒体文件 |
| 0x03 | MEDIA_INFO_REQUEST | - | 请求媒体信息 |
| 0x04 | MEDIA_INFO_RESPONSE | - | 媒体信息响应 |
| 0x05 | MEDIA_PREVIEW_REQUEST | - | 请求媒体预览图 |
| 0x06 | MEDIA_PREVIEW_RESPONSE | - | 媒体预览图响应 |
| 0x07 | MEDIA_PREVIEW_PUSH_REQUEST | - | 请求推送预览图数据 |
| 0x08 | MEDIA_PREVIEW_PUSH_RESPONSE | - | 预览图推送响应 |
| 0x09 | MEDIA_BACKGROUND_REQUEST | - | 请求背景图 |
| 0x0A | MEDIA_BACKGROUND_RESPONSE | - | 背景图响应 |
| 0x0B | MEDIA_BACKGROUND_PUSH_REQUEST | - | 请求推送背景图数据 |
| 0x0C | MEDIA_BACKGROUND_PUSH_RESPONSE | - | 背景图推送响应 |
| 0x0D | MEDIA_ID_REQUEST | - | 请求分配媒体ID |
| 0x0E | MEDIA_ID_RESPONSE | - | 媒体ID分配响应 |
| 0x0F | RESERVED | - | 预留扩展 |
| 0x10 | RESERVED | - | 预留扩展 |

**注释说明:**
- **媒体列表**: 获取设备上存储的媒体文件列表
- **媒体删除**: 删除指定的媒体文件
- **媒体信息**: 获取媒体文件的详细信息
- **媒体预览图**: 获取媒体文件的缩略图预览
- **预览图推送**: 主动请求设备推送预览图数据
- **背景图**: 获取当前设置的背景图片
- **背景图推送**: 主动请求设备推送背景图数据
- **媒体ID分配**: 为新文件请求分配媒体ID

#### 4.4.2 媒体列表响应协议实现

**媒体列表响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x01 | MEDIA_LIST_RESPONSE命令 |
| | 7 | 1 | [媒体数量] | 媒体文件数量(0-255) |
| | 8-N | 可变 | [媒体信息列表] | 每个媒体文件的信息 |

**每个媒体文件信息结构:**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 4 | [媒体ID] | 媒体文件唯一标识符 |
| 4 | 4 | [文件大小] | 文件大小(字节) |
| 8 | 1 | [文件类型] | 文件类型(0x01-0x03) |
| 9 | 16 | [文件MD5] | 文件MD5校验值(16字节) |
| 25 | 1 | [内部元素数量] | 媒体文件包含的内部元素数量 (0-255) |
| 26-N | 可变 | [内部元素列表] | 内部元素列表，每个元素包含类型、长度和数据 |

**内部元素结构:**

每个内部元素的结构如下：

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | [元素类型] | 内部元素类型 (0x01=贴纸, 0x02=时间, 0x03=文字等) |
| 1 | 1 | [元素长度] | 当前元素数据部分的长度 (字节数) |
| 2-N | 可变 | [元素数据] | 元素具体数据，根据元素类型而定 |

**元素类型定义:**

| 元素类型 | 名称 | 数据长度 | 说明 |
|---------|------|----------|------|
| 0x01 | 贴纸元素 | 8字节 | 包含贴纸ID(4字节)和坐标信息(4字节) |
| 0x02 | 时间元素 | 8字节 | 包含时间样式ID(4字节)和坐标信息(4字节) |
| 0x03 | 文字元素 | 可变 | 包含文字内容和坐标信息 |
| 0x04-0xFF | 预留 | - | 为未来扩展预留 |

**贴纸元素数据结构 (元素类型=0x01):**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 4 | [贴纸ID] | 贴纸唯一标识符 |
| 4 | 2 | [贴纸X坐标] | 贴纸左上角X坐标，相对于图片左上角 |
| 6 | 2 | [贴纸Y坐标] | 贴纸左上角Y坐标，相对于图片左上角 |

**时间元素数据结构 (元素类型=0x02):**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 4 | [时间样式ID] | 时间显示样式标识符 |
| 4 | 2 | [时间X坐标] | 时间显示区域X坐标，相对于图片左上角 |
| 6 | 2 | [时间Y坐标] | 时间显示区域Y坐标，相对于图片左上角 |

**媒体列表响应示例:**
```
假设设备上有3个媒体文件:
1. 媒体ID: 0x00000001 (1024字节, 图片, MD5: 0x1234567890ABCDEF1234567890ABCDEF, 包含1个贴纸元素和1个时间元素)
2. 媒体ID: 0x00000002 (2048字节, 视频, MD5: 0x2345678901BCDEF12345678901BCDEF1, 无内部元素)
3. 媒体ID: 0x00000003 (512字节, 图片, MD5: 0x3456789012CDEF123456789012CDEF12, 包含2个贴纸元素)

完整响应数据包:
0xCD 0x00 0x7A 0x25 0x01 0x02 0x01 0x03 0x00 0x00 0x00 0x01 0x00 0x00 0x04 0x00 0x01 0x12 0x34 0x56 0x78 0x90 0xAB 0xCD 0xEF 0x12 0x34 0x56 0x78 0x90 0xAB 0xCD 0xEF 0x02 0x01 0x08 0x00 0x00 0x00 0x01 0x00 0x64 0x00 0x32 0x02 0x08 0x00 0x00 0x00 0x01 0x00 0xC8 0x00 0x1E 0x00 0x00 0x00 0x02 0x00 0x00 0x08 0x00 0x02 0x23 0x45 0x67 0x89 0x01 0xBC 0xDE 0xF1 0x23 0x45 0x67 0x89 0x01 0xBC 0xDE 0xF1 0x00 0x00 0x00 0x03 0x00 0x00 0x02 0x00 0x01 0x34 0x56 0x78 0x90 0x12 0xCD 0xEF 0x12 0x34 0x56 0x78 0x90 0x12 0xCD 0xEF 0x12 0x02 0x01 0x08 0x00 0x00 0x00 0x02 0x00 0x32 0x00 0x64 0x01 0x08 0x00 0x00 0x00 0x03 0x00 0x96 0x00 0xC8

数据包解析:
- 0xCD 0x00 0x7A: 包头(数据长度122字节)
- 0x25 0x01: 命令ID和版本
- 0x02 0x01: MEDIA_MANAGEMENT + MEDIA_LIST_RESPONSE
- 0x03: 媒体文件数量(3个)

第一个文件 (媒体ID=1, 大小=1024, 类型=图片, MD5=0x1234567890ABCDEF1234567890ABCDEF, 内部元素数量=2):
- 0x00 0x00 0x00 0x01 0x00 0x00 0x04 0x00 0x01: 基本信息(媒体ID, 大小, 类型)
- 0x12 0x34 0x56 0x78 0x90 0xAB 0xCD 0xEF 0x12 0x34 0x56 0x78 0x90 0xAB 0xCD 0xEF: MD5值
- 0x02: 内部元素数量
- 0x01 0x08 0x00 0x00 0x00 0x01 0x00 0x64 0x00 0x32: 贴纸元素(类型=1, 长度=8, ID=1, 坐标(100,50))
- 0x02 0x08 0x00 0x00 0x00 0x01 0x00 0xC8 0x00 0x1E: 时间元素(类型=2, 长度=8, 样式=1, 坐标(200,30))

第二个文件 (媒体ID=2, 大小=2048, 类型=视频, MD5=0x2345678901BCDEF12345678901BCDEF1, 内部元素数量=0):
- 0x00 0x00 0x00 0x02 0x00 0x00 0x08 0x00 0x02: 基本信息
- 0x23 0x45 0x67 0x89 0x01 0xBC 0xDE 0xF1 0x23 0x45 0x67 0x89 0x01 0xBC 0xDE 0xF1: MD5值
- 0x00: 内部元素数量(无内部元素)

第三个文件 (媒体ID=3, 大小=512, 类型=图片, MD5=0x3456789012CDEF123456789012CDEF12, 内部元素数量=2):
- 0x00 0x00 0x00 0x03 0x00 0x00 0x02 0x00 0x01: 基本信息
- 0x34 0x56 0x78 0x90 0x12 0xCD 0xEF 0x12 0x34 0x56 0x78 0x90 0x12 0xCD 0xEF 0x12: MD5值
- 0x02: 内部元素数量
- 0x01 0x08 0x00 0x00 0x00 0x02 0x00 0x32 0x00 0x64: 贴纸元素1(类型=1, 长度=8, ID=2, 坐标(50,100))
- 0x01 0x08 0x00 0x00 0x00 0x03 0x00 0x96 0x00 0xC8: 贴纸元素2(类型=1, 长度=8, ID=3, 坐标(150,200))
```

#### 4.4.3 媒体删除协议实现

**媒体删除请求数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x02 | MEDIA_DELETE命令 |
| | 7-10 | 4 | [媒体ID] | 要删除的媒体文件ID |

**媒体删除响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 0x05 | 起始标识符 + 数据长度(5字节) |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x02 | MEDIA_DELETE命令 |
| | 7 | 1 | [状态码] | 删除结果状态码 |

**删除状态码定义:**

| 状态码 | 描述 | 说明 |
|--------|------|------|
| 0x00 | 删除成功 | 文件已成功删除 |
| 0x01 | 文件不存在 | 指定的文件不存在 |
| 0x02 | 权限不足 | 没有删除权限 |
| 0x03 | 文件正在使用 | 文件正在被其他进程使用 |
| 0x04 | 存储错误 | 存储设备错误 |

#### 4.4.4 媒体信息查询协议实现

**媒体信息请求数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x03 | MEDIA_INFO_REQUEST命令 |
| | 7-10 | 4 | [媒体ID] | 要查询的媒体文件ID |

**媒体信息响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x04 | MEDIA_INFO_RESPONSE命令 |
| | 7 | 1 | [状态码] | 查询状态码 |
| | 8-N | 可变 | [文件信息] | 文件详细信息(如果成功) |

**文件详细信息结构:**

| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 4 | [媒体ID] | 媒体文件唯一标识符 |
| 4 | 4 | [文件大小] | 文件大小(字节) |
| 8 | 1 | [文件类型] | 文件类型(0x01-0x03) |
| 9 | 16 | [文件MD5] | 文件MD5校验值(16字节) |
| 25 | 1 | [内部元素数量] | 媒体文件包含的内部元素数量 (0-255) |
| 26-N | 可变 | [内部元素列表] | 内部元素列表，每个元素包含类型、长度和数据 |

**查询状态码定义:**

| 状态码 | 描述 | 说明 |
|--------|------|------|
| 0x00 | 查询成功 | 文件信息获取成功 |
| 0x01 | 文件不存在 | 指定的文件不存在 |
| 0x02 | 权限不足 | 没有读取权限 |
| 0x03 | 文件损坏 | 文件已损坏无法读取 |
| 0x04 | 存储错误 | 存储设备错误 |

#### 4.4.5 媒体预览图协议实现

**媒体预览图请求数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x05 | MEDIA_PREVIEW_REQUEST命令 |
| | 7-10 | 4 | [媒体ID] | 要获取预览图的媒体文件ID |

**媒体预览图响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x06 | MEDIA_PREVIEW_RESPONSE命令 |
| | 7 | 1 | [状态码] | 请求状态码 |
| | 8-11 | 4 | [预览图大小] | 预览图数据大小(字节) |
| | 12-27 | 16 | [预览图MD5] | 预览图MD5校验值 |

**状态码定义:**
| 状态码 | 名称 | 描述 |
|--------|------|------|
| 0x00 | 成功 | 预览图信息获取成功 |
| 0x01 | 文件不存在 | 指定的媒体文件不存在 |
| 0x02 | 预览图不存在 | 该媒体文件没有预览图 |
| 0x03 | 文件类型不支持 | 该文件类型不支持预览图 |
| 0x04 | 存储错误 | 存储设备错误 |

#### 4.4.6 预览图推送协议实现

**预览图推送请求数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x07 | MEDIA_PREVIEW_PUSH_REQUEST命令 |
| | 7-10 | 4 | [媒体ID] | 要推送预览图的媒体文件ID |

**预览图推送响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x08 | MEDIA_PREVIEW_PUSH_RESPONSE命令 |
| | 7-10 | 4 | [媒体ID] | 推送预览图的媒体文件ID |
| | 11 | 1 | [状态码] | 推送状态码 |

**推送状态码定义:**
| 状态码 | 名称 | 描述 |
|--------|------|------|
| 0x00 | 推送开始 | 开始推送预览图数据 |
| 0x01 | 文件不存在 | 指定的媒体文件不存在 |
| 0x02 | 预览图不存在 | 该媒体文件没有预览图 |
| 0x03 | 推送失败 | 预览图推送失败 |
| 0x04 | 存储错误 | 存储设备错误 |

**预览图数据传输协议:**
当APP需要获取预览图数据时，使用文件传输协议进行分块传输：

1. **推送请求**: APP发送 `MEDIA_PREVIEW_PUSH_REQUEST` 命令
2. **推送确认**: 设备返回推送状态码
3. **传输协商**: 使用 `FILE_TRANSFER` 模块的 `TRANSFER_START` 命令
4. **文件信息**: 包含预览图大小、MD5等信息
5. **分块传输**: 使用 `FILE_DATA` 命令分块传输预览图数据
6. **完整性验证**: 使用CRC32校验确保传输完整性

#### 4.4.7 背景图协议实现

**背景图请求数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x07 | MEDIA_BACKGROUND_REQUEST命令 |
| | 7-10 | 4 | [媒体ID] | 要获取背景图的媒体文件ID |

**背景图信息响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x08 | MEDIA_BACKGROUND_RESPONSE命令 |
| | 7 | 1 | [状态码] | 请求状态码 |
| | 8-11 | 4 | [背景图大小] | 背景图数据大小(字节) |
| | 12-27 | 16 | [背景图MD5] | 背景图MD5校验值 |

**状态码定义:**
| 状态码 | 名称 | 描述 |
|--------|------|------|
| 0x00 | 成功 | 背景图信息获取成功 |
| 0x01 | 无背景图 | 设备当前没有设置背景图 |
| 0x02 | 背景图损坏 | 背景图文件损坏或无法读取 |
| 0x03 | 存储错误 | 存储设备错误 |
| 0x04 | 文件不存在 | 指定的媒体文件不存在 |

#### 4.4.7 背景图推送协议实现

**背景图推送请求数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x0B | MEDIA_BACKGROUND_PUSH_REQUEST命令 |
| | 7-10 | 4 | [媒体ID] | 要推送背景图的媒体文件ID |

**背景图推送响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x0C | MEDIA_BACKGROUND_PUSH_RESPONSE命令 |
| | 7-10 | 4 | [媒体ID] | 推送背景图的媒体文件ID |
| | 11 | 1 | [状态码] | 推送状态码 |

**推送状态码定义:**
| 状态码 | 名称 | 描述 |
|--------|------|------|
| 0x00 | 推送开始 | 开始推送背景图数据 |
| 0x01 | 文件不存在 | 指定的媒体文件不存在 |
| 0x02 | 无背景图 | 该媒体文件没有背景图 |
| 0x03 | 推送失败 | 背景图推送失败 |
| 0x04 | 存储错误 | 存储设备错误 |

**背景图数据传输协议:**
当APP需要获取背景图数据时，使用文件传输协议进行分块传输：

1. **推送请求**: APP发送 `MEDIA_BACKGROUND_PUSH_REQUEST` 命令
2. **推送确认**: 设备返回推送状态码
3. **传输协商**: 使用 `FILE_TRANSFER` 模块的 `TRANSFER_START` 命令
4. **文件信息**: 包含背景图大小、MD5等信息
5. **分块传输**: 使用 `FILE_DATA` 命令分块传输背景图数据
6. **完整性验证**: 使用CRC32校验确保传输完整性

**注释说明:**
- **预览图功能**: 为媒体文件提供缩略图预览，支持MD5校验和分块传输
- **背景图功能**: 获取设备当前设置的背景图片，支持MD5校验和分块传输
- **MD5校验机制**: 
  * APP先请求预览图/背景图信息(大小+MD5)
  * 比较本地缓存文件的MD5与设备端MD5
  * 如果MD5不同，则启动文件传输协议获取新图片
  * 如果MD5相同，则直接使用本地缓存
- **分块传输**: 大图片使用文件传输协议进行分块传输
- **格式支持**: 预览图和背景图通常为JPEG或PNG格式
- **缓存机制**: 设备端可以缓存预览图，APP端缓存图片以提高响应速度
- **预览图工作流程**:
  1. APP发送预览图请求(包含媒体ID)
  2. 设备返回预览图信息(大小+MD5)
  3. APP比较MD5，决定是否需要传输
  4. 如需要，APP发送预览图推送请求
  5. 设备确认推送请求
  6. 使用文件传输协议分块获取预览图数据
- **背景图工作流程**:
  1. APP发送背景图请求(包含媒体ID)
  2. 设备返回背景图信息(大小+MD5)
  3. APP比较MD5，决定是否需要传输
  4. 如需要，APP发送背景图推送请求
  5. 设备确认推送请求
  6. 使用文件传输协议分块获取背景图数据

#### 4.4.8 预览图和背景图推送协议流程图

**预览图推送协议完整流程图:**

```
APP端                          设备端
  |                              |
  |-- 1. 预览图请求(媒体ID) ----->|
  |   0xCD 0x00 0x0A 0x25 0x01   |
  |   0x02 0x05 [媒体ID]         |
  |                              |
  |<-- 2. 预览图信息响应 ---------|
  |   0xCD 0x00 0x1A 0x25 0x01   |
  |   0x02 0x06 [状态码]         |
  |   [大小] [MD5]               |
  |                              |
  |-- 3. MD5比较检查 --           |
  |   本地MD5 vs 设备MD5         |
  |                              |
  |-- 4a. MD5相同，使用缓存 --    |
  |   直接显示本地预览图         |
  |                              |
  |-- 4b. MD5不同，请求推送 ----->|
  |   0xCD 0x00 0x0A 0x25 0x01   |
  |   0x02 0x07 [媒体ID]         |
  |                              |
  |<-- 5. 推送响应确认 -----------|
  |   0xCD 0x00 0x0E 0x25 0x01   |
  |   0x02 0x08 [媒体ID] [状态码] |
  |                              |
  |-- 6. 媒体ID确认 --            |
  |   验证响应对应的请求         |
  |                              |
  |-- 7. 文件传输协商 ----------->|
  |   0xCD 0x00 0x0D 0x25 0x01   |
  |   0x01 0x00 [文件信息]       |
  |                              |
  |<-- 8. 传输确认 --------------|
  |   0xCD 0x00 0x08 0x25 0x01   |
  |   0x01 0x04 [状态码]         |
  |                              |
  |-- 9. 分块传输请求 ----------->|
  |   0xCD 0x00 0xXX 0x25 0x01   |
  |   0x01 0x0A [块数据]         |
  |                              |
  |<-- 10. 块传输确认 -----------|
  |    0xCD 0x00 0x08 0x25 0x01  |
  |    0x01 0x0B [状态码]        |
  |                              |
  |-- 11. 重复9-10直到完成 --     |
  |                              |
  |-- 12. 传输完成确认 ---------->|
  |    0xCD 0x00 0x0C 0x25 0x01  |
  |    0x01 0x1A [CRC32]         |
  |                              |
  |<-- 13. 验证结果响应 ----------|
  |    0xCD 0x00 0x08 0x25 0x01  |
  |    0x01 0x1C [验证结果]      |
  |                              |
  |-- 14. 保存预览图到缓存 --     |
  |    更新本地MD5缓存           |
```

**背景图推送协议完整流程图:**

```
APP端                          设备端
  |                              |
  |-- 1. 背景图请求(媒体ID) ----->|
  |   0xCD 0x00 0x0A 0x25 0x01   |
  |   0x02 0x09 [媒体ID]         |
  |                              |
  |<-- 2. 背景图信息响应 ---------|
  |   0xCD 0x00 0x1A 0x25 0x01   |
  |   0x02 0x0A [状态码]         |
  |   [大小] [MD5]               |
  |                              |
  |-- 3. MD5比较检查 --           |
  |   本地MD5 vs 设备MD5         |
  |                              |
  |-- 4a. MD5相同，使用缓存 --    |
  |   直接使用本地背景图         |
  |                              |
  |-- 4b. MD5不同，请求推送 ----->|
  |   0xCD 0x00 0x0A 0x25 0x01   |
  |   0x02 0x0B [媒体ID]         |
  |                              |
  |<-- 5. 推送响应确认 -----------|
  |   0xCD 0x00 0x0E 0x25 0x01   |
  |   0x02 0x0C [媒体ID] [状态码] |
  |                              |
  |-- 6. 媒体ID确认 --            |
  |   验证响应对应的请求         |
  |                              |
  |-- 7. 文件传输协商 ----------->|
  |   0xCD 0x00 0x0D 0x25 0x01   |
  |   0x01 0x00 [文件信息]       |
  |                              |
  |<-- 8. 传输确认 --------------|
  |   0xCD 0x00 0x08 0x25 0x01   |
  |   0x01 0x04 [状态码]         |
  |                              |
  |-- 9. 分块传输请求 ----------->|
  |   0xCD 0x00 0xXX 0x25 0x01   |
  |   0x01 0x0A [块数据]         |
  |                              |
  |<-- 10. 块传输确认 -----------|
  |    0xCD 0x00 0x08 0x25 0x01  |
  |    0x01 0x0B [状态码]        |
  |                              |
  |-- 11. 重复9-10直到完成 --     |
  |                              |
  |-- 12. 传输完成确认 ---------->|
  |    0xCD 0x00 0x0C 0x25 0x01  |
  |    0x01 0x1A [CRC32]         |
  |                              |
  |<-- 13. 验证结果响应 ----------|
  |    0xCD 0x00 0x08 0x25 0x01  |
  |    0x01 0x1C [验证结果]      |
  |                              |
  |-- 14. 保存背景图到缓存 --     |
  |    更新本地MD5缓存           |
```

**协议关键点说明:**

1. **MD5校验机制**: 避免重复传输相同文件，提高效率
2. **媒体ID确认**: 确保响应对应正确的请求
3. **分块传输**: 支持大文件的分块传输
4. **完整性验证**: CRC32校验确保传输完整性
5. **缓存机制**: 本地缓存提高响应速度
6. **错误处理**: 每个步骤都有相应的错误处理机制

**数据包格式说明:**
- `0xCD 0x00 [长度]`: BLE协议头部
- `0x25 0x01`: 命令ID和版本
- `0x02`: 媒体管理功能标识
- `0x01`: 文件传输功能标识
- `[媒体ID]`: 4字节媒体文件标识符
- `[状态码]`: 1字节状态信息
- `[大小]`: 4字节文件大小
- `[MD5]`: 16字节MD5校验值
- `[CRC32]`: 4字节CRC32校验值

#### 4.4.9 媒体ID分配协议实现

**媒体ID分配请求数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x0D | MEDIA_ID_REQUEST命令 |

**媒体ID分配响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x02 | MEDIA_MANAGEMENT功能标识 |
| | 6 | 1 | 0x0E | MEDIA_ID_RESPONSE命令 |
| | 7 | 1 | [状态码] | 分配状态码 |
| | 8-11 | 4 | [媒体ID] | 分配的媒体ID(如果成功) |

**分配状态码定义:**
| 状态码 | 名称 | 描述 |
|--------|------|------|
| 0x00 | 分配成功 | 媒体ID分配成功 |
| 0x01 | 分配失败 | 媒体ID分配失败 |
| 0x02 | 存储空间不足 | 设备存储空间不足 |
| 0x03 | 存储错误 | 存储设备错误 |

**媒体ID分配协议流程图:**

```
APP端                          设备端
  |                              |
  |-- 1. 媒体ID分配请求 --------->|
  |   0xCD 0x00 0x08 0x25 0x01   |
  |   0x02 0x0D                  |
  |                              |
  |<-- 2. 媒体ID分配响应 ---------|
  |   0xCD 0x00 0x0E 0x25 0x01   |
  |   0x02 0x0E [状态码]         |
  |   [媒体ID]                   |
  |                              |
  |-- 3. 状态码检查 --            |
  |   0x00: 分配成功，使用新ID   |
  |   0x01-0x03: 分配失败        |
  |                              |
  |-- 4. 使用分配的媒体ID --      |
  |   进行后续的文件传输操作     |
```

**注释说明:**
- **媒体ID分配**: 为新文件请求分配唯一的媒体ID
- **简单请求**: 只需要发送分配请求，无需文件信息
- **存储检查**: 分配前检查设备存储空间
- **ID管理**: 设备端统一管理媒体ID的分配和回收
- **使用场景**: 
  * 新文件上传前需要分配媒体ID
  * 编辑文件时保持原有媒体ID
  * 设备端自动分配递增的媒体ID

### 4.5 SYSTEM_INFO (0x03) - 系统信息功能
| 键值 | 名称 | 数据类型 | 描述 |
|------|------|----------|------|
| 0x00 | DEVICE_INFO_REQUEST | - | 请求设备信息 |
| 0x01 | DEVICE_INFO_RESPONSE | - | 设备信息响应 |

#### 4.5.1 设备信息请求协议实现

**设备信息请求数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x03 | SYSTEM_INFO功能标识 |
| | 6 | 1 | 0x00 | DEVICE_INFO_REQUEST命令 |

#### 4.5.2 设备信息响应协议实现

**设备信息响应数据包结构:**

| 部分 | 字节位置 | 字节数 | 内容 | 描述 |
|------|---------|--------|------|------|
| **数据包头部** | 0-2 | 3 | 0xCD 0x00 [数据长度] | 起始标识符 + 数据长度 |
| **数据部分** | 3-4 | 2 | 0x25 0x01 | 命令ID + 协议版本 |
| **载荷数据** | 5 | 1 | 0x03 | SYSTEM_INFO功能标识 |
| | 6 | 1 | 0x01 | DEVICE_INFO_RESPONSE命令 |
| | 7 | 1 | 0x02 | 屏幕宽度数据长度(2字节) |
| | 8 | 1 | [宽度高字节] | 屏幕宽度高字节 |
| | 9 | 1 | [宽度低字节] | 屏幕宽度低字节 |
| | 10 | 1 | 0x02 | 屏幕高度数据长度(2字节) |
| | 11 | 1 | [高度高字节] | 屏幕高度高字节 |
| | 12 | 1 | [高度低字节] | 屏幕高度低字节 |
| | 13 | 1 | 0x01 | 屏幕类型数据长度(1字节) |
| | 14 | 1 | [屏幕类型] | 屏幕类型值 |
| | 15 | 1 | 0x02 | 单包发送大小数据长度(2字节) |
| | 16 | 1 | [包大小高字节] | 单包发送大小高字节 |
| | 17 | 1 | [包大小低字节] | 单包发送大小低字节 |

**屏幕类型定义:**
- 0x00: 方屏
- 0x01: 圆屏

**注释说明:**
- **设备信息获取**: 在固件升级前，APP需要获取设备的屏幕信息
- **屏幕适配**: 根据屏幕类型(圆屏/方屏)和尺寸调整显示效果
- **升级兼容性**: 确保升级包与设备屏幕规格兼容
- **单包发送大小**: 设备端BLE单包最大发送字节数，用于文件传输分块大小计算
- **协议一致性**: 请求和响应使用不同的命令码，保持协议一致性

---

## 5. 文件传输流程

### 5.1 详细文件传输流程图

**流程说明:**
本流程图展示了完整的BLE文件传输过程，包括准备阶段、传输阶段和完成阶段。每个步骤都有明确的命令和数据交互。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            BLE文件传输完整流程                                  │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────┐                    ┌─────────────┐
│     APP     │                    │    设备     │
└─────────────┘                    └─────────────┘
       │                                   │
       │ 1. TRANSFER_START + 文件信息        │
       │ ──────────────────────────────────→ │
       │    (文件名、大小、类型、ID、总块数)    │
       │                                   │
       │                                   │ 2. 检查文件信息
       │                                   │    - 存储空间是否足够？
       │                                   │    - 文件类型是否支持？
       │                                   │    - 文件大小是否超限？
       │                                   │
       │                                   │ 2.1. 更新状态: PREPARING (0x01)
       │                                   │
       │ 3a. TRANSFER_ACK (确认)            │
       │ ←────────────────────────────────── │
       │    (传输确认)                       │
       │                                   │
       │ 或者                               │
       │                                   │
       │ 3b. TRANSFER_NACK + 拒绝原因        │
       │ ←────────────────────────────────── │
       │    (存储不足/类型不支持/文件过大)     │
       │                                   │
       │                                   │ 3.1. 更新状态: ERROR (0x05)
       │                                   │
       │                                   │ 3.1. 准备接收缓冲区
       │                                   │ 3.2. 更新状态: TRANSFERRING (0x02)
       │                                   │
       │ 4. FILE_DATA + 第1块数据            │
       │ ──────────────────────────────────→ │
       │    (数据块 + 索引 + 大小 + 校验和)    │
       │                                   │
       │                                   │ 5. 验证数据块
       │                                   │    - 校验和是否正确？
       │                                   │    - 数据是否完整？
       │                                   │
       │ 6a. NEXT_CHUNK_REQUEST             │
       │ ←────────────────────────────────── │
       │    (请求下一块)                     │
       │                                   │
       │ 或者                               │
       │                                   │
       │ 6b. RETRY_REQUEST + 错误信息        │
       │ ←────────────────────────────────── │
       │    (校验失败/数据损坏)               │
       │                                   │
       │                                   │
       │ 7. FILE_DATA + 第2块数据            │
       │ ──────────────────────────────────→ │
       │    (重复发送数据块)                  │
       │                                   │
       │                                   │
       │ 8. NEXT_CHUNK_REQUEST              │
       │ ←────────────────────────────────── │
       │    (继续请求下一块)                  │
       │                                   │
       │                                   │
       │ 9. ... (重复步骤7-8)               │
       │    直到所有数据块传输完成            │
       │                                   │
       │                                   │
       │ 10. TRANSFER_COMPLETE              │
       │ ──────────────────────────────────→ │
       │    (传输完成标志 + 文件CRC32)       │
       │                                   │
       │                                   │ 10.1. 最终验证
       │                                   │    - 所有块是否接收完整？
       │                                   │    - 文件是否完整？
       │                                   │ 10.2. 更新状态: COMPLETED (0x04)
       │                                   │
       │ 11. VERIFICATION_RESULT            │
       │ ←────────────────────────────────── │
       │    (验证结果)                       │
       │                                   │
       │                                   │
       │ 12. 传输成功！                      │
       │                                   │
```

### 5.2 错误处理流程

**错误处理说明:**
当数据传输过程中出现错误时，系统会自动进行错误检测和重传处理，确保数据传输的可靠性。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              错误处理流程                                      │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────┐                    ┌─────────────┐
│     APP     │                    │    设备     │
└─────────────┘                    └─────────────┘
       │                                   │
       │ 1. 数据块传输                      │
       │ ──────────────────────────────────→ │
       │                                   │
       │                                   │ 2. 检测到错误
       │                                   │    - 校验和错误
       │                                   │    - 数据损坏
       │                                   │    - 超时
       │                                   │ 2.1. 更新状态: ERROR (0x05)
       │                                   │
       │ 3. RETRY_REQUEST + 错误信息         │
       │ ←────────────────────────────────── │
       │    (错误代码 + 错误描述)             │
       │                                   │
       │ 4. 重传数据块                      │
       │ ──────────────────────────────────→ │
       │    (相同的数据块)                   │
       │                                   │
       │                                   │ 4.1. 重新验证
       │                                   │ 4.2. 更新状态: TRANSFERRING (0x02)
       │                                   │
       │ 5a. NEXT_CHUNK_REQUEST             │
       │ ←────────────────────────────────── │
       │    (重传成功，继续下一块)            │
       │                                   │
       │ 或者                               │
       │                                   │
       │ 5b. RETRY_REQUEST                  │
       │ ←────────────────────────────────── │
       │    (重传失败，继续重试)              │
       │                                   │
       │                                   │
       │ 6. 达到最大重试次数                 │
       │ ──────────────────────────────────→ │
       │    (放弃传输)                       │
       │                                   │ 6.1. 更新状态: ERROR (0x05)
       │                                   │
       │ 7. ERROR_MESSAGE                   │
       │ ←────────────────────────────────── │
       │    (传输失败)                       │
       │                                   │
```

### 5.3 状态查询流程

**状态查询说明:**
APP可以随时查询设备的传输状态，了解当前传输进度和状态信息。

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              状态查询流程                                      │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────┐                    ┌─────────────┐
│     APP     │                    │    设备     │
└─────────────┘                    └─────────────┘
       │                                   │
       │ 1. STATUS查询请求                  │
       │ ──────────────────────────────────→ │
       │    (查询当前传输状态)               │
       │                                   │
       │                                   │ 2. 检查当前状态
       │                                   │    - 传输进度
       │                                   │    - 错误信息
       │                                   │
       │ 3. STATUS响应                      │
       │ ←────────────────────────────────── │
       │    (返回状态值)                     │
       │                                   │
       │                                   │
       │ 4. 根据状态执行相应操作              │
       │    - 显示进度                      │
       │    - 处理错误                      │
       │    - 更新UI                        │
       │                                   │
```

### 5.4 设备信息获取流程 (升级前)

**设备信息获取说明:**
在固件升级前，APP需要获取设备的屏幕信息，确保升级包与设备兼容。

```
1. APP -> 设备: 0x25 0x01 0x03 0x00 (请求设备信息)
2. 设备 -> APP: 0x25 0x01 0x03 0x00 + 屏幕信息数据
```

---

## 6. 数据包示例

### 6.1 单文件传输示例

**示例说明:**
展示APP点击"开始发送"时发送的完整数据包，包含文件大小4096字节、图片类型、贴纸功能等信息。

```
完整数据包:
0xCD 0x00 0x0F 0x25 0x01 0x00 0x07 0x00 0x00 0x10 0x00 0x08 0x01 0x0A 0x02 0x09 0x00 0x00 0x00 0x01

数据包解析:
- 0xCD 0x00 0x0F: 包头(数据长度15字节)
- 0x25 0x01: 命令ID和版本
- 0x00: TRANSFER_START命令
- 0x07: FILE_SIZE标识
- 0x00 0x00 0x10 0x00: 文件大小(4096字节)
- 0x08: FILE_TYPE标识
- 0x01: 文件类型(图片)
- 0x0A: FUNCTION_TYPE标识
- 0x02: 功能类型(贴纸功能)
- 0x09: MEDIA_ID标识
- 0x00 0x00 0x00 0x01: 媒体ID(1)
```

### 6.2 传输拒绝示例 (存储空间不足)

**拒绝示例说明:**
展示当设备存储空间不足时，返回拒绝响应的完整数据包格式。

```
设备拒绝响应:
数据包头部:
0xCD 0x00 0x06  (起始标识符 + 数据长度6字节)

数据部分:
0x25 0x01       (命令ID: BAJI_PRODUCT + 协议版本: v1.0)

载荷数据:
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x05 | TRANSFER_NACK命令 |
| 2 | 1 | 0x03 | 拒绝原因(存储空间不足) |

完整拒绝数据包:
0xCD 0x00 0x06 0x25 0x01 0x01 0x05 0x03
```

### 6.3 设备信息获取示例 (屏幕信息)

**设备信息示例说明:**
展示获取设备屏幕信息的完整交互过程，包括请求和响应数据包。

```
客户端请求:
数据包头部:
0xCD 0x00 0x05  (起始标识符 + 数据长度5字节)

数据部分:
0x25 0x01       (命令ID: BAJI_PRODUCT + 协议版本: v1.0)

载荷数据:
0x03 0x00 0x00  (SYSTEM_INFO: 系统信息功能 + DEVICE_INFO_REQUEST: 请求设备信息)

服务端响应:
数据包头部:
0xCD 0x00 0x0A  (起始标识符 + 数据长度10字节)

数据部分:
0x25 0x01       (命令ID: BAJI_PRODUCT + 协议版本: v1.0)

载荷数据 (字节级结构):
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x02 | 屏幕宽度数据长度(2字节) |
| 1 | 1 | 0x01 | 屏幕宽度高字节 (320>>8) |
| 2 | 1 | 0x40 | 屏幕宽度低字节 (320&0xFF) |
| 3 | 1 | 0x02 | 屏幕高度数据长度(2字节) |
| 4 | 1 | 0x00 | 屏幕高度高字节 (240>>8) |
| 5 | 1 | 0xF0 | 屏幕高度低字节 (240&0xFF) |
| 6 | 1 | 0x01 | 屏幕类型数据长度(1字节) |
| 7 | 1 | 0x01 | 屏幕类型值 (圆屏) |

完整响应数据包:
0xCD 0x00 0x0A 0x25 0x01 0x02 0x01 0x40 0x02 0x00 0xF0 0x01 0x01
```

### 6.4 状态查询示例
```
APP查询状态:
数据包头部:
0xCD 0x00 0x05  (起始标识符 + 数据长度5字节)

数据部分:
0x25 0x01       (命令ID: BAJI_PRODUCT + 协议版本: v1.0)

载荷数据:
0x01 0x1D  (FILE_TRANSFER: 文件传输功能 + STATUS: 状态查询)

设备状态响应:
数据包头部:
0xCD 0x00 0x06  (起始标识符 + 数据长度6字节)

数据部分:
0x25 0x01       (命令ID: BAJI_PRODUCT + 协议版本: v1.0)

载荷数据:
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x1D | STATUS命令 |
| 2 | 1 | 0x02 | 状态值(传输中) |

完整状态响应数据包:
0xCD 0x00 0x06 0x25 0x01 0x01 0x1D 0x02
```

### 6.5 数据块传输与校验和验证示例
```
APP发送数据块:
数据包头部:
0xCD 0x00 0x20  (起始标识符 + 数据长度32字节)

数据部分:
0x25 0x01       (命令ID: BAJI_PRODUCT + 协议版本: v1.0)

载荷数据 (字节级结构):
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x0A | FILE_DATA命令 |
| 2 | 1 | 0x10 | 数据块大小(16字节) |
| 3-18 | 16 | [数据块内容] | 实际文件数据(16字节) |
| 19-20 | 2 | 0x00 0x01 | 数据块索引(第1块) |
| 21-24 | 4 | 0x12 0x34 0x56 0x78 | CRC32校验和 |

完整数据包:
0xCD 0x00 0x20 0x25 0x01 0x01 0x0A 0x10 [16字节数据] 0x00 0x01 0x12 0x34 0x56 0x78

设备验证响应 (成功):
数据包头部:
0xCD 0x00 0x05  (起始标识符 + 数据长度5字节)

数据部分:
0x25 0x01       (命令ID: BAJI_PRODUCT + 协议版本: v1.0)

载荷数据:
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x17 | NEXT_CHUNK_REQUEST命令 |

完整响应数据包:
0xCD 0x00 0x05 0x25 0x01 0x01 0x17

设备验证响应 (失败):
数据包头部:
0xCD 0x00 0x06  (起始标识符 + 数据长度6字节)

数据部分:
0x25 0x01       (命令ID: BAJI_PRODUCT + 协议版本: v1.0)

载荷数据:
| 字节位置 | 字节数 | 内容 | 描述 |
|---------|--------|------|------|
| 0 | 1 | 0x01 | FILE_TRANSFER功能标识 |
| 1 | 1 | 0x19 | RETRY_REQUEST命令 |
| 2 | 1 | 0x05 | 错误代码(校验和错误) |

完整响应数据包:
0xCD 0x00 0x06 0x25 0x01 0x01 0x19 0x05
```

---

## 7. 文件类型定义

### 7.1 支持的文件类型
| 类型值 | 文件类型 | 扩展名 | 描述 |
|--------|----------|--------|------|
| 0x01 | 图片 | JPG, PNG, BMP, WEBP | 静态图片文件 |
| 0x02 | 视频 | MP4, AVI, MOV | 视频文件 |
| 0x03 | 动画 | GIF, APNG | 动画文件 |

---

## 8. 错误代码定义

### 8.1 传输错误代码
| 错误代码 | 描述 | 处理方式 |
|----------|------|----------|
| 0x00 | 成功 | 继续传输 |
| 0x01 | 文件过大 | 拒绝传输 |
| 0x02 | 文件类型不支持 | 拒绝传输 |
| 0x03 | 存储空间不足 | 拒绝传输 |
| 0x04 | 传输超时 | 重试传输 |
| 0x05 | 校验和错误 | 重传数据块 |
| 0x06 | 设备忙 | 稍后重试 |

---

## 9. 实现建议

### 9.1 数据块大小建议
- **BLE MTU**: 建议使用20-244字节
- **数据块大小**: 建议16-200字节 (预留协议开销)
- **大文件**: 自动分片传输

### 9.2 传输优化
- **握手确认**: 每个数据块都需要确认
- **错误重传**: 失败的数据块自动重传
- **进度显示**: 根据已传输块数计算进度
- **超时处理**: 设置合理的超时时间

---

## 10. 协议总结

### 10.1 核心特点
- **简单高效**: 只保留文件传输核心功能
- **结构清晰**: 三级Key结构，易于理解和实现
- **扩展性强**: 预留扩展空间，支持未来功能增加
- **错误处理**: 完善的错误检测和重传机制

### 10.2 使用场景
- **图片传输**: 支持各种格式的图片文件
- **视频传输**: 支持常见视频格式
- **GIF传输**: 支持动画文件传输
- **固件升级**: 升级前获取设备屏幕信息

### 10.3 协议优势
- **精简设计**: 去除了所有冗余功能
- **专注核心**: 只关注文件传输和设备信息获取
- **易于实现**: 协议结构简单，开发成本低
- **稳定可靠**: 完善的错误处理机制